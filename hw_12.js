

console.log('start');

const promise1 = new Promise((resolve, reject) => {
console.log(1)
resolve(2)
})

promise1.then(res => {
console.log(res)
})

console.log('end');

/* 
Вивід у консолі буде:
sql
Copy code
start
1
end
2


Даний демонструє, як працюють проміси в JavaScript. Кроки виконання:

console.log('start'); - Виводить "start".
Створюється новий проміс (promise1). Коли проміс створюється, його функція викликається негайно.
console.log(1) - Виводить 1.
resolve(2) - Змінює стан промісу на "виконано" (fulfilled) з результатом 2. Але обробка результату промісу (.then) буде відкладена до завершення усіх синхронних операцій.
console.log('end'); - Виводить "end".
Після завершення синхронних операцій, JavaScript обробляє відкладені асинхронні завдання, такі як .then від promise1.
console.log(res) всередині .then виводить результат промісу - 2.
*/

Promise.resolve(1)
		.then((x) => x + 1)
		.then((x) => { throw new Error('My Error') })
		.catch(() => 1)
		.then((x) => x + 1)
		.then((x) => console.log(x))
		.catch(console.error)

        /*
        Використання промісів та їхніх методів then та catch у JavaScript. Виконання:

Promise.resolve(1) створює проміс, який відразу виконується зі значенням 1.
.then((x) => x + 1) приймає 1, додає 1, і повертає 2.
.then((x) => { throw new Error('My Error') }) приймає 2, але кидає помилку, тому подальші then не виконуються.
.catch(() => 1) обробляє помилку і повертає 1.
.then((x) => x + 1) приймає 1 (результат попереднього catch), додає 1 і повертає 2.
.then((x) => console.log(x)) приймає 2 і виводить його у консоль.
Останній .catch(console.error) не виконується, оскільки немає помилок у попередніх ланках ланцюжка.
Тому, в консоль буде виведено 2. Цей приклад ілюструє, як проміси можна об'єднувати в ланцюжки та обробляти помилки.
        
  */

const promise = new Promise(res => res(2));
	promise.then(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .then(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .finally(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .then(v => {
	        console.log(v);
	    });

/*
У консолі буде виведено:

javascript
Copy code
2
4
undefined
8

Робота з методами then та finally. Ось як цей код працює:

Створюється проміс promise, який відразу виконується з результатом 2.
Перший .then обробляє результат і виводить його в консоль (2), потім повертає v * 2, що дорівнює 4.
Другий .then отримує 4, виводить його в консоль і повертає v * 2, що дорівнює 8.
.finally виконується після завершення попередніх промісів, але він не приймає значення результату або помилки промісу (v буде undefined), 
і його результат не передається далі в ланцюжок. Він виводить undefined в консоль.
Останній .then отримує значення, повернуте попереднім .then (яке є 8), але, оскільки .finally не змінює значення, виводить 8 в консоль.
        */

